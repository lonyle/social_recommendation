# edited on 2019-1-5: we do not choose a random user from the candidates, but we choose the user who enter the queue first
import queue

import random
import math
import hashlib
import argparse
#import mcts

import facebook_osn
import yelp_osn


# record the global state of the depth-first search, the state reports whether each user adopt the item
#global_graph = None

class Graph():
	''' the graph that is used to find the optimal policy for given parameters
	'''
	def __init__(self, delta, rec_prob_func, adopt_prob_func):
		print ('constructing the simulator over a graph')
		#self.edges = facebook_osn.get_edges() # load the graph
		self.edges = yelp_osn.get_edges() # load the Yelp graph
		self.nodes = self.edges.keys()
		self.N_user = len(self.edges)
		self.N_other_info = int(self.N_user * delta)
	
		self.rec_prob_func = rec_prob_func
		self.adopt_prob_func = adopt_prob_func

		self.feedbacks = dict() # whether adopt and whether recommend
		self.reset()

	def reset(self):
		# print ('resetting the graph')
		self.is_recommended = dict()
		for node in self.nodes:
			self.is_recommended[node] = False

		self.N_is_recommended = 0
		# randomly choose int(N_users * delta) in the later_other_info
		
		random_other_info = list(random.sample(self.nodes, self.N_other_info))
		self.random_other_info_set = set(random_other_info)
		# edited on 2019-1-5: return a shuffled list
		random.shuffle(random_other_info) 
		self.later_other_info = random_other_info[:]# the users who will be informed by others, randomly assigned at beginning
		self.newly_recommended_queue = queue.Queue() # now, not a set, but a queue
		self.cost_on_reward = 0
		self.gross_profit = 0
		self.n = 0 # initially, no user is informed from other information

	def next(self, action):
		''' randomly pick a user in the newly_recommended_queue,
			then decide the users' action according to the sales strategy (action) of the firm
			the action of the chosen user decide the next state
			return: the changed state of the social network
		'''
		#print ('calling the next function, action:', action)
		transition_profit = 0 # the profit gain by transiting from the current state to the next state
		self.feedbacks = {'adopt': None, 'recommend': None}

		if self.newly_recommended_queue.empty() == True: # if no user is newly recommended
			if len(self.later_other_info) > 0:
				# let one of the users in later_other_info to be informed
				while True: # wait until the first user who is not informed from other information
					selected_user = self.later_other_info.pop()
					if self.is_recommended[selected_user] == False: # only for the users who have not receive recommendations
						break
				self.n += 1
				
			else: # no user will be informed by any information sources
				return transition_profit # no next state, skip the processing for selected_user
		else: # if some selected user is newly recommended
			selected_user = self.newly_recommended_queue.get()
			
			self.is_recommended[selected_user] = True
			self.N_is_recommended += 1

			if selected_user in self.random_other_info_set:
				return transition_profit # do nothing, already been informed by other information

		# currently, the users informed from other_info or from recommendations have the same prob.
		adopt_prob = self.adopt_prob_func(action['price'], action['reward'])
		rec_prob = self.rec_prob_func(action['price'], action['reward'])
		adopt_prob = min(1, adopt_prob)
		rec_prob = min(1, rec_prob)

		transition_profit += adopt_prob * action['price']
		transition_profit -= rec_prob * action['reward']

		if random.random() < adopt_prob:
			self.gross_profit += action['price'] # representing price-cost		
			self.feedbacks['adopt'] = True
		else:
			self.feedbacks['adopt'] = False
			
		# assume only the adopter will recommend
		if random.random() < rec_prob: # this fomula assume recommendation and adoption are independent, which is ok as only recommendation matters for disffusion
			# the spending on the reward 
			self.cost_on_reward += action['reward']
			self.feedbacks['recommend'] = True
			# the friends of this user will receive recommendation
			for friend in self.edges[selected_user]:
				## for Yelp, some friend may not be in the social network? For such cases, continue
				if friend not in self.is_recommended:
					continue
				if self.is_recommended[friend] == False: # newly recommended
					self.newly_recommended_queue.put(friend)
				# if friend in self.later_other_info: # someone will not receive other info
				# 	self.later_other_info.remove(friend)
		else:
			self.feedbacks['recommend'] = False

		return transition_profit

	def current_state_param(self): # return the state needed by MCTS
		m = self.N_is_recommended # optimize, directly return the number of recommended
		delta_m = self.newly_recommended_queue.qsize()
		delta_n = len(self.later_other_info) # who will be informed from other information
		n = self.n
		if m % 100000 == 0:
			print ('current_state_param: m=%d, delta_m=%d, n=%d, delta_n=%d'%(m, delta_m, n, delta_n) )
		return m, delta_m, n, delta_n


	# more used by thompson_sampling
	def get_feedbacks(self):
		# know whether adopt or recommend
		return self.feedbacks

	def is_terminated(self):
		m, delta_m, n, delta_n = self.current_state_param()
		if delta_m + delta_n == 0:
			return True
		return False






